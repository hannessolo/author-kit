{
  "version": 3,
  "sources": ["../src/utils.js", "../src/components/source-marker-embedder.js", "../src/components/iframe-page-renderer.js", "../src/components/decorator-page-renderer.js", "../src/components/page-marker-mapper.js", "../src/mapper-service.js", "../src/config.js", "../src/orchestrator.js"],
  "sourcesContent": ["/**\n * Utility functions for hash mapper\n */\n\n/**\n * Generates a unique random ID\n * @param {number} length - Length of the ID (default: random between 6-8)\n * @returns {string} Random alphanumeric string\n */\nexport function generateRandomId(length = null) {\n  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  const idLength = length || (Math.random() < 0.5 ? 6 : 8);\n  let result = '';\n  for (let i = 0; i < idLength; i += 1) {\n    result += chars.charAt(Math.floor(Math.random() * chars.length));\n  }\n  return result;\n}\n\n/**\n * Builds a stable path from root to element\n * @param {Element} element - Element to get path for\n * @param {Element} root - Root element to stop at\n * @returns {Array} Path descriptor array with {tag, index} objects\n */\nexport function getElementPath(element, root) {\n  const path = [];\n  let current = element;\n\n  while (current && current !== root) {\n    const parent = current.parentElement;\n\n    // Stop if we've reached root or no parent\n    if (!parent || parent === root) {\n      // Add current element to path before stopping (direct child of root)\n      const siblings = Array.from(root.children);\n      const index = siblings.indexOf(current);\n\n      path.unshift({\n        tag: current.tagName,\n        index,\n      });\n      break;\n    }\n\n    // Add current element to path\n    const siblings = Array.from(parent.children);\n    const index = siblings.indexOf(current);\n\n    path.unshift({\n      tag: current.tagName,\n      index,\n    });\n\n    current = parent;\n  }\n\n  return path;\n}\n\n/**\n * Gets an element by its path descriptor\n * @param {Element} root - Root element\n * @param {Array} path - Path descriptor array\n * @returns {Element|null} Element or null if not found\n */\nexport function getElementByPath(root, path) {\n  let current = root;\n\n  for (const step of path) {\n    if (!current) return null;\n\n    // Direct index access - no need to convert HTMLCollection to Array\n    const candidate = current.children[step.index];\n\n    if (!candidate) return null;\n\n    // Verify tag name matches\n    if (candidate.tagName !== step.tag) {\n      return null;\n    }\n\n    current = candidate;\n  }\n\n  return current;\n}\n\n", "/**\n * Source Hash Embedder Component\n * Pure function that embeds tracking markers into source HTML\n * \n * Performance: Builds markerToSourcePath during embedding (one DOM traversal)\n */\n\nimport { generateRandomId, getElementPath as getPath } from '../utils.js';\n\n/**\n * Creates a hash identifier\n * @param {string} elementType - Type of element (H1, P, IMG, etc)\n * @param {string} contentType - Type of content (TEXT, SRC, ALT, HTML)\n * @param {string} prefix - Hash prefix\n * @param {number} idLength - Length of random ID\n * @returns {string} Hash identifier\n */\nfunction createMarker(elementType, contentType, prefix, idLength) {\n  const randomId = generateRandomId(idLength);\n  return `${prefix}${elementType}_${randomId}_${contentType}`;\n}\n\n/**\n * Gets the depth of an element from the root\n * @param {Element} element - Element to get depth for\n * @param {Element} root - Root element\n * @returns {number} Depth from root\n */\nfunction getDepth(element, root) {\n  let depth = 0;\n  let current = element;\n  while (current && current !== root) {\n    depth += 1;\n    current = current.parentElement;\n  }\n  return depth;\n}\n\n/**\n * Gets the first text node that belongs directly to the element\n * (not within a child element)\n * @param {Element} element - Element to search\n * @returns {Text|null} First text node or null\n */\nfunction getFirstOwnTextNode(element) {\n  for (const node of element.childNodes) {\n    if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {\n      return node;\n    }\n  }\n  return null;\n}\n\n/**\n * Embeds tracking markers into target elements\n * Pure function: takes HTML string and config, returns data\n * \n * @param {string} sourceHTML - Raw HTML string\n * @param {Object} config - Configuration object (merged with defaults by orchestrator)\n * @returns {Object} Object containing markedHTML, markerMap, and markerToSourcePath\n */\nfunction embedSourceMarkers(sourceHTML, config) {\n  const {\n    rootSelector,\n    targetSelectors,\n    markerPrefix,\n    markerIdLength,\n  } = config;\n\n  const parser = new DOMParser();\n  const doc = parser.parseFromString(sourceHTML, 'text/html');\n\n  const markerMap = new Map();\n  const markerToSourcePath = new Map();\n\n  // Find root element\n  const root = doc.body.querySelector(rootSelector);\n  if (!root) {\n    console.warn(`[Source Embedder] No ${rootSelector} element found in source HTML`);\n    return { markedHTML: sourceHTML, markerMap, markerToSourcePath };\n  }\n\n  // Convert targetSelectors array to comma-separated string for querySelectorAll\n  const targetSelectorsStr = Array.isArray(targetSelectors)\n    ? targetSelectors.join(', ')\n    : targetSelectors;\n  const targetElements = root.querySelectorAll(targetSelectorsStr);\n\n  // Convert NodeList to Array and process in reverse order (deepest first)\n  // This ensures child elements get their markers before parent elements\n  const elementsArray = Array.from(targetElements);\n\n  // Sort by depth (deepest first) to process children before parents\n  elementsArray.sort((a, b) => {\n    const depthA = getDepth(a, root);\n    const depthB = getDepth(b, root);\n    return depthB - depthA; // Reverse order: deepest first\n  });\n\n  elementsArray.forEach((element) => {\n    const elementType = element.tagName;\n    const elementMarkers = [];\n\n    if (elementType === 'IMG') {\n      // Only modify src and alt attributes; preserve all others\n      const originalSrc = element.getAttribute('src') || '';\n      if (originalSrc) {\n        const srcMarker = createMarker(elementType, 'SRC', markerPrefix, markerIdLength);\n        markerMap.set(srcMarker, {\n          type: 'attribute',\n          name: 'src',\n          value: originalSrc,\n          element: elementType,\n        });\n        element.setAttribute('src', srcMarker);\n        elementMarkers.push(srcMarker);\n      }\n    } else if (['UL', 'OL'].includes(elementType)) {\n      const listItems = element.querySelectorAll(':scope > li');\n      listItems.forEach((li) => {\n        const originalLiHTML = li.innerHTML || '';\n        if (originalLiHTML.trim()) {\n          const htmlMarker = createMarker('LI', 'HTML', markerPrefix, markerIdLength);\n          markerMap.set(htmlMarker, {\n            type: 'html',\n            value: originalLiHTML,\n            element: 'LI',\n          });\n          li.innerHTML = htmlMarker;\n\n          const liPath = getPath(li, root);\n          markerToSourcePath.set(htmlMarker, liPath);\n\n          li.setAttribute('data-marker-ids', htmlMarker);\n          li.setAttribute('data-source-marked', 'true');\n        }\n      });\n    } else {\n      // For text elements, inject marker while preserving child elements\n      // Only process elements that have some content (text or children)\n\n      const hasContent = element.textContent.trim() || element.childNodes.length > 0;\n\n      if (hasContent) {\n        const htmlMarker = createMarker(elementType, 'HTML', markerPrefix, markerIdLength);\n\n        // Store the original innerHTML (with all nested structure)\n        const originalHTML = element.innerHTML || '';\n\n        markerMap.set(htmlMarker, {\n          type: 'html',\n          value: originalHTML,\n          element: elementType,\n        });\n\n        // Inject marker at the beginning while preserving all child elements\n        const markerNode = element.ownerDocument.createTextNode(htmlMarker + ' ');\n        element.insertBefore(markerNode, element.firstChild);\n\n        elementMarkers.push(htmlMarker);\n      }\n    }\n\n    // Store mapping of element to its markers\n    if (elementMarkers.length > 0) {\n      const path = getPath(element, root);\n\n      // Store the markers as a data attribute for later retrieval\n      element.setAttribute('data-marker-ids', elementMarkers.join(','));\n      element.setAttribute('data-source-marked', 'true');\n\n      // Track path for each marker so we can find the source element later\n      // This is done during embedding for performance (one DOM traversal)\n      elementMarkers.forEach((marker) => {\n        markerToSourcePath.set(marker, path);\n      });\n    }\n  });\n\n  const markedHTML = doc.body.outerHTML;\n\n  return {\n    markedHTML,\n    markerMap,\n    markerToSourcePath,\n    sourceDoc: doc,\n  };\n}\n\nexport default embedSourceMarkers;\n\n", "/**\n * URL Page Renderer Component\n * Loads a real production page URL and injects marked HTML before scripts execute\n * \n * This simulates exactly how the page behaves in production\n */\n\n/**\n * Creates a hidden iframe for page rendering\n * @returns {Promise<HTMLIFrameElement>} The created iframe\n */\nfunction createHiddenIframe() {\n  return new Promise((resolve) => {\n    const iframe = document.createElement('iframe');\n    iframe.style.display = 'none';\n    iframe.style.position = 'absolute';\n    iframe.style.width = '100%';\n    iframe.style.height = '100%';\n    iframe.style.border = 'none';\n    iframe.setAttribute('data-page-mapper-url', 'true');\n\n    iframe.addEventListener('load', () => {\n      resolve(iframe);\n    });\n\n    document.body.appendChild(iframe);\n  });\n}\n\n/**\n * Waits for a condition to be met in the iframe\n * @param {Window} iframeWindow - The iframe window\n * @param {Object} waitFor - Wait condition configuration\n * @returns {Promise<void>}\n */\nasync function waitForCondition(iframeWindow, waitFor) {\n  if (!waitFor) {\n    // Default: wait a short time for scripts to execute\n    await new Promise(resolve => setTimeout(resolve, 500));\n    return;\n  }\n\n  const startTime = Date.now();\n  const timeout = waitFor.timeout || 10000;\n\n  if (waitFor.type === 'delay') {\n    // Simple delay\n    await new Promise(resolve => setTimeout(resolve, waitFor.ms));\n    return;\n  }\n\n  if (waitFor.type === 'event') {\n    // Wait for custom event\n    return new Promise((resolve, reject) => {\n      const timer = setTimeout(() => {\n        reject(new Error(`[URL Renderer] Timeout waiting for event: ${waitFor.name}`));\n      }, timeout);\n\n      iframeWindow.addEventListener(waitFor.name, () => {\n        clearTimeout(timer);\n        resolve();\n      }, { once: true });\n    });\n  }\n\n  // Poll for condition\n  while (Date.now() - startTime < timeout) {\n    if (waitFor.type === 'function') {\n      // Wait for a window property to be truthy\n      if (iframeWindow[waitFor.fn]) {\n        return;\n      }\n    } else if (waitFor.type === 'selector') {\n      // Wait for element to appear\n      if (iframeWindow.document.querySelector(waitFor.value)) {\n        return;\n      }\n    }\n\n    await new Promise(resolve => setTimeout(resolve, 50));\n  }\n\n  console.warn(`[URL Renderer] Wait condition timeout after ${timeout}ms`);\n}\n\n/**\n * Renders page by loading production URL and injecting marked HTML\n * \n * @param {string} markedHTML - HTML with embedded markers\n * @param {Object} options - URL rendering options\n * @param {string} options.url - Production page URL to load\n * @param {string} options.rootSelector - Selector for root element to replace\n * @param {Object} options.waitFor - Condition to wait for before extracting HTML\n * @param {Function} options.setupContext - Optional function to setup iframe context\n * @returns {Promise<string>} Rendered page HTML as a string\n */\nasync function renderPageFromURL(markedHTML, options) {\n  const {\n    url,\n    rootSelector = 'main',\n    waitFor,\n    setupContext\n  } = options;\n\n  if (!url) {\n    throw new Error('[URL Renderer] url is required');\n  }\n\n  let iframe = null;\n\n  try {\n    // Fetch the production page content\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`[URL Renderer] Failed to fetch ${url}: ${response.status}`);\n    }\n\n    let pageHTML = await response.text();\n\n    // Parse both the production page and marked HTML\n    const parser = new DOMParser();\n    const pageDoc = parser.parseFromString(pageHTML, 'text/html');\n    const markedDoc = parser.parseFromString(markedHTML, 'text/html');\n\n    // Inject marked HTML into production page structure\n    const pageRoot = pageDoc.querySelector(rootSelector);\n    const markedRoot = markedDoc.querySelector(rootSelector);\n\n    if (!pageRoot) {\n      throw new Error(`[URL Renderer] Root element ${rootSelector} not found in page from ${url}`);\n    }\n    if (!markedRoot) {\n      throw new Error(`[URL Renderer] Root element ${rootSelector} not found in marked HTML`);\n    }\n\n    // Replace content but keep page structure (head, scripts, etc.)\n    pageRoot.innerHTML = markedRoot.innerHTML;\n\n    // Create iframe and load modified page\n    iframe = await createHiddenIframe();\n    const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;\n    const iframeWindow = iframe.contentWindow;\n\n    // Setup context before loading page\n    if (setupContext && typeof setupContext === 'function') {\n      setupContext(iframeWindow);\n    }\n\n    // Write the modified page HTML\n    iframeDoc.open();\n    iframeDoc.write(pageDoc.documentElement.outerHTML);\n    iframeDoc.close();\n\n    // Wait for page scripts to finish decorating\n    await waitForCondition(iframeWindow, waitFor);\n\n    // Extract final HTML\n    const renderedHTML = iframeDoc.documentElement.outerHTML;\n\n    // Cleanup\n    if (iframe && iframe.parentNode) {\n      iframe.remove();\n    }\n\n    return renderedHTML;\n\n  } catch (error) {\n    console.error('[URL Renderer] Error during rendering:', error);\n    if (iframe && iframe.parentNode) {\n      iframe.remove();\n    }\n    throw error;\n  }\n}\n\nexport default renderPageFromURL;\n\n", "async function renderPageWithRenderers(markedHTML, options = {}) {\n  const { renderers = [], rootSelector = 'main' } = options;\n\n  try {\n    const parser = new DOMParser();\n    const doc = parser.parseFromString(markedHTML, 'text/html');\n    const root = doc.querySelector(rootSelector);\n\n    if (!root) {\n      throw new Error(`[Renderer] Root \"${rootSelector}\" not found`);\n    }\n\n    for (let i = 0; i < renderers.length; i++) {\n      const renderer = renderers[i];\n      if (typeof renderer !== 'function') {\n        throw new Error(`[Renderer] Renderer ${i} is not a function`);\n      }\n      await renderer(root, doc);\n    }\n\n    return doc.documentElement.outerHTML;\n  } catch (error) {\n    console.error('[Renderer] Error:', error);\n    throw error;\n  }\n}\n\nexport default renderPageWithRenderers;\n", "/**\n * Page Hash Mapper Component\n * Pure function that builds mapping between rendered page and source elements\n * \n * @implements {IMarkerMapper}\n */\n\nimport { getElementPath } from '../utils.js';\n\n/**\n * Builds a map of all markers found in the rendered page document\n * Performs a single tree walk for better performance\n * @param {Element} root - Root element to search within\n * @param {Document} doc - Document to search in\n * @param {Object} config - Configuration object\n * @returns {Map<string, {element: Element, path: Array}>} Map of marker -> {element, path}\n */\nfunction buildRenderedPageMarkerMap(root, doc, config) {\n  const markerMap = new Map();\n  const markerPrefix = config.markerPrefix;\n  const markerPattern = new RegExp(`\\\\b${markerPrefix}[A-Z0-9]+_[a-zA-Z0-9]+_[A-Z]+\\\\b`, 'g');\n\n  // Walk entire document tree\n  const walker = doc.createTreeWalker(root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT);\n  let node = walker.currentNode;\n\n  while (node) {\n    if (node.nodeType === Node.TEXT_NODE && node.textContent) {\n      // Check text node content for markers (handles H1, P, etc.)\n      const matches = node.textContent.match(markerPattern);\n      if (matches) {\n        const parent = node.parentElement;\n        if (parent) {\n          matches.forEach((marker) => {\n            if (marker.startsWith(markerPrefix)) {\n              // Always use the deepest (leaf) element\n              // If marker exists, only replace if this element is deeper\n              const existingInfo = markerMap.get(marker);\n              const newPath = getElementPath(parent, root);\n\n              if (!existingInfo || newPath.length > existingInfo.path.length) {\n                markerMap.set(marker, { element: parent, path: newPath });\n              }\n            }\n          });\n        }\n      }\n    } else if (node.nodeType === Node.ELEMENT_NODE && node.tagName === 'IMG') {\n      // Special handling for IMG elements - check src attribute\n      const src = node.getAttribute('src');\n      if (src) {\n        const matches = src.match(markerPattern);\n        if (matches) {\n          matches.forEach((marker) => {\n            if (marker.startsWith(markerPrefix) && !markerMap.has(marker)) {\n              const path = getElementPath(node, root);\n              markerMap.set(marker, { element: node, path });\n            }\n          });\n        }\n      }\n    }\n    node = walker.nextNode();\n  }\n\n  return markerMap;\n}\n\n/**\n * Builds page element mapping\n * Pure function: takes documents and marker data, returns mapping\n * \n * @param {Document} renderedPageDoc - Rendered page document\n * @param {Document} sourceDoc - Source document\n * @param {Map} markerToSourcePath - Marker to source path mapping (from embedder)\n * @param {Object} config - Configuration object (merged with defaults by orchestrator)\n * @returns {Object} Object containing markerToPagePath\n */\nfunction buildPageMapping(renderedPageDoc, sourceDoc, markerToSourcePath, config) {\n  const renderedPageRoot = renderedPageDoc.querySelector(config.rootSelector);\n  const sourceRoot = sourceDoc.querySelector(config.rootSelector);\n  const markerToPagePath = new Map();\n\n  if (!renderedPageRoot || !sourceRoot) {\n    console.warn(`[Page Mapper] Cannot build mapping: missing ${config.rootSelector} elements`);\n    return { markerToPagePath };\n  }\n\n  if (!markerToSourcePath || markerToSourcePath.size === 0) {\n    console.warn('[Page Mapper] No markers registered in markerToSourcePath');\n    return { markerToPagePath };\n  }\n\n  // Build a map of all markers found in rendered page doc (single pass for performance)\n  const renderedPageMarkerMap = buildRenderedPageMarkerMap(renderedPageRoot, renderedPageDoc, config);\n\n  // Match registered markers to rendered page markers\n  markerToSourcePath.forEach((sourcePath, marker) => {\n    const renderedPageMarkerInfo = renderedPageMarkerMap.get(marker);\n\n    if (renderedPageMarkerInfo && renderedPageMarkerInfo.path) {\n      // Store marker -> page path mapping\n      markerToPagePath.set(marker, renderedPageMarkerInfo.path);\n    }\n  });\n\n  return { markerToPagePath };\n}\n\n\nexport default buildPageMapping;\n\n", "import { getElementPath, getElementByPath } from './utils.js';\n\nfunction serializePathKey(path) {\n  if (!path) return '';\n  return path.map(s => `${s.tag}[${s.index}]`).join('>');\n}\n\nexport class MapperService {\n  constructor(options = {}) {\n    const { sourceDoc, markerToSourcePath, markerToPagePath, config, markedHTML, decoratedHTML } = options;\n    this.sourceDoc = sourceDoc;\n    this.markerToSourcePath = markerToSourcePath;\n    this.markerToPagePath = markerToPagePath;\n    this.config = config;\n    this._markedHTML = markedHTML;\n    this._decoratedHTML = decoratedHTML;\n\n    this.pagePathToMarker = new Map();\n    for (const [marker, pagePath] of markerToPagePath.entries()) {\n      this.pagePathToMarker.set(serializePathKey(pagePath), marker);\n    }\n  }\n\n  getMarkedHTML() {\n    return this._markedHTML;\n  }\n\n  getDecoratedHTML() {\n    return this._decoratedHTML;\n  }\n\n  findSourceElement(pageElement) {\n    const doc = pageElement.ownerDocument;\n    const pageRoot = doc.querySelector(this.config.rootSelector);\n    if (!pageRoot) return null;\n\n    const pagePath = getElementPath(pageElement, pageRoot);\n    const marker = this.pagePathToMarker.get(serializePathKey(pagePath));\n    if (!marker) return null;\n\n    const sourcePath = this.markerToSourcePath.get(marker);\n    if (!sourcePath) return null;\n\n    const sourceRoot = this.sourceDoc.querySelector(this.config.rootSelector);\n    if (!sourceRoot) return null;\n\n    return getElementByPath(sourceRoot, sourcePath);\n  }\n\n  getSourceDoc() {\n    return this.sourceDoc;\n  }\n\n  getAllMappedElements(pageDoc = null) {\n    const mappedPairs = [];\n    const sourceRoot = this.sourceDoc.querySelector(this.config.rootSelector);\n    const targetDoc = pageDoc || (typeof document !== 'undefined' ? document : null);\n    if (!sourceRoot || !targetDoc) return mappedPairs;\n\n    const pageRoot = targetDoc.querySelector(this.config.rootSelector);\n    if (!pageRoot) return mappedPairs;\n\n    for (const [marker, sourcePath] of this.markerToSourcePath.entries()) {\n      const pagePath = this.markerToPagePath.get(marker);\n      if (!pagePath) continue;\n\n      const sourceElement = getElementByPath(sourceRoot, sourcePath);\n      if (!sourceElement) continue;\n\n      const pageElement = getElementByPath(pageRoot, pagePath);\n      if (!pageElement) continue;\n\n      mappedPairs.push({\n        marker,\n        source: { element: sourceElement, path: sourcePath },\n        page: { element: pageElement, path: pagePath }\n      });\n    }\n\n    return mappedPairs;\n  }\n}\n\nexport default MapperService;\n\n", "const DEFAULT_CONFIG = {\n  rootSelector: 'main',\n  targetSelectors: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'img', 'ul', 'ol'],\n  timeout: 10000,\n  logPerformance: true,\n  markerPrefix: 'MARKER_',\n  markerIdLength: 8,\n  setupContext: null,\n};\n\nexport default DEFAULT_CONFIG;\n\n", "import embedSourceMarkers from './components/source-marker-embedder.js';\nimport renderPageFromURL from './components/iframe-page-renderer.js';\nimport renderPageWithRenderers from './components/decorator-page-renderer.js';\nimport buildPageMapping from './components/page-marker-mapper.js';\nimport { MapperService } from './mapper-service.js';\nimport DEFAULT_CONFIG from './config.js';\n\nconst RENDERERS = {\n  'iframe': renderPageFromURL,\n  'renderers': renderPageWithRenderers,\n};\n\nfunction logPerformanceMetrics(metrics, elementMappingCount) {\n  console.log('[Page Mapper] Performance:', {\n    embeddingMs: metrics.embeddingTime.toFixed(2),\n    renderingMs: metrics.renderingTime.toFixed(2),\n    mappingMs: metrics.mappingTime.toFixed(2),\n    totalMs: metrics.totalTime.toFixed(2),\n    elementMappingCount,\n  });\n}\n\nasync function initializeMapper(sourceHTML, config = {}) {\n  const mergedConfig = { ...DEFAULT_CONFIG, ...config };\n  const totalStart = performance.now();\n  const metrics = {};\n\n  try {\n    const embeddingStart = performance.now();\n    const { markedHTML, markerToSourcePath, sourceDoc } = embedSourceMarkers(sourceHTML, mergedConfig);\n    metrics.embeddingTime = performance.now() - embeddingStart;\n\n    const { renderMode, renderOptions } = mergedConfig;\n    if (!renderMode) {\n      throw new Error('[Page Mapper] renderMode is required. Available: ' + Object.keys(RENDERERS).join(', '));\n    }\n\n    const renderer = RENDERERS[renderMode];\n    if (!renderer) {\n      throw new Error(`[Page Mapper] Unknown renderMode \"${renderMode}\". Available: ${Object.keys(RENDERERS).join(', ')}`);\n    }\n\n    const renderingStart = performance.now();\n    const renderedPageHTML = await renderer(markedHTML, renderOptions || {});\n    metrics.renderingTime = performance.now() - renderingStart;\n\n    const renderedPageDoc = new DOMParser().parseFromString(renderedPageHTML, 'text/html');\n\n    const mappingStart = performance.now();\n    const { markerToPagePath } = buildPageMapping(renderedPageDoc, sourceDoc, markerToSourcePath, mergedConfig);\n    metrics.mappingTime = performance.now() - mappingStart;\n    metrics.totalTime = performance.now() - totalStart;\n\n    if (mergedConfig.logPerformance) {\n      logPerformanceMetrics(metrics, markerToPagePath.size);\n    }\n\n    return new MapperService({\n      sourceDoc,\n      markerToSourcePath,\n      markerToPagePath,\n      config: mergedConfig,\n      markedHTML,\n      decoratedHTML: renderedPageHTML,\n    });\n  } catch (error) {\n    console.error('[Page Mapper] Initialization failed:', error);\n    throw error;\n  }\n}\n\nexport default initializeMapper;\n"],
  "mappings": "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",
  "names": ["siblings", "index"]
}
